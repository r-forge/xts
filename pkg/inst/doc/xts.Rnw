%\VignetteIndexEntry{xts: Extensible Time Series}
\documentclass{article}
\usepackage{hyperref}
\hypersetup{colorlinks,%
            citecolor=black,%
            linkcolor=blue,%
            urlcolor=blue,%
            }

\title{\bf xts: Extensible Time Series }
\author{Jeffrey A. Ryan \and Joshua M. Ulrich}
\date{April 9, 2008}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}
The statistical language {\tt R}~\cite{R}
 offers the time-series analyst a variety of mechanisms
to both store and manage time-indexed data.  
Native {\tt R} classes potentially suitable
for time-series data include {\tt data.frame}, {\tt matrix}, {\tt vector}, and
{\tt ts} objects. Additional time-series tools have been subsequently introduced 
in contributed packages to
handle some of the shortcomings of the native {\tt R} classes.
These include {\tt irts} from the {\tt tseries} package\cite{tseries},
{\tt timeSeries} from the {\tt Rmetrics} bundle\cite{rmetrics}, and
{\tt its}~\cite{its} and {\tt zoo}~\cite{zoo} from their 
respective packages. Each of these contributed classes provide unique solutions
to many of the issues
related to working with time-series in R.

While it seems a bit paradoxical with all current options
available, what {\tt R} really needed was one more
time-series class.  Why? Users of R have had many choices over the
years for managing time-series data. This variety has meant that
developers have had to pick and choose the classes they would support,
or impose the necessary conversions upon the end-user. With the sheer
magnitude of software packages available from CRAN, it has become a challenge
for users and developers 
to select a time-series class that will manage the needs of the
individual user, as well as remain compatible with the broadest audience.

What may be sufficient for one use - say a quick correlation matrix, may be
too limiting when more information needs to be incorporated 
in a complex calculation.
This is especially true for functions that rely on time-based indicies to
be manipulated or checked.

The previous solution to managing different data needs often
involved a series of {\tt as} calls,
to coerce objects from one type to another.  While this may
be sufficient for many cases, it is less flexible than allowing for the user
to simply use the object they are accustomed to, or quite possibly require.
Additionally, all current coercion methods fail to maintain the original
object's data in its entirety.  Converting from a {\tt timeSeries} class to
{\tt zoo} would cause attributes such as 
{\em FinCenter}, {\em format}, and {\em recordIDs} to be lost.
Converting back to a {\tt timeSeries} would then add new
values different than the original.
For many calculations that do not modify the data, this is most likely
an acceptable side effect.  For functions that convert data -
such as {\tt xts}'s {\tt to.period} it limits the value of the function,
as the returned object is missing
much of what may have been a factor in the original class consideration.

One of the most important additions the new {\tt xts} class makes
to the R user's
workflow is possibly not using {\tt xts} at all, at least not explicitly.
By converting data to {\tt xts} inside a function, the function developer
is guaranteed to have to only manage a single class of objects. 
It becomes unecessary to write specific methods to handle different data.
While many functions do have
methods to accommodate different classes, most do not. Before {\tt xts}, the
{\tt chartSeries} function in the {\tt quantmod} package
was only able to handle zoo objects well.
Work had been done to allow for timeSeries object to be used as well, but
many issues were still being worked out.
With {\tt xts} now used internally, it is
possible to use \emph{any} of R's time-series classes.
Simultaneously saving development time and
reducing the learning/using curve for the end user.  The function now
simply handles whatever time-series object it receives
exactly as the user expects - without complaint.
More details, as well as examples of incorporating {\tt xts} into
functions will be covered later in this document.

While it may seem that {\tt xts} is primarily a tool
to help make existing R code
more user friendly, the opportunity to add exciting
(to software people) new functionality
could not be passed up.  To this end, {\tt xts} 
offers the user the ability to add
custom attributes to any object - during its construction
or at any time thereafter.  Additionally,
by requiring the index attribute be derived from one of
R's existing time-based classes, {\tt xts} methods can
make assumptions while subsetting by time or date that allow for
much cleaner and accurate data manipulation.

The remainder of this introduction will
examine what exactly an {\tt xts} object consists of,
its basic usage, explain how developing with {\tt xts} can save
package development time, and finally how to extend the class - informally
and formally.

\section{The structure of {\tt xts}}
To understand a bit more of \emph{what an xts object can do}, it may
be beneficial to know \emph{what an xts object is}. This section
is intended to provide a quick overview of the basics of the
class, as well as what features make it unique.

\subsection{It's a {\tt zoo} in here}
At the core of an {\tt xts} object is a {\tt zoo} object from the package of
the same name. Simplified, this class contains an array of values
comprising your data --- often in matrix form --- and an index
attribute to provide information about
the data's ordering. Most of the details surrounding zoo
objects apply equally to xts. As it would be redundent to simply retell
the excellent introductory zoo vingette, the reader is advised to
read, absorb, and re-read that documentation to best
understand the power of this class. The authors of the {\tt xts}
package recognize that
{\tt zoo}'s strength comes from its
simplicity of use, as well as its overall flexibility.  What motivated the
{\tt xts} extension was a desire to have even more flexibility, while 
imposing reasonable constraints to make this class into a true time-based one.

\subsection{{\tt xts} modifications}
Objects of class {\tt xts} differ from objects of class 
{\tt zoo} in three key ways: the use of formal time-based
classes for indexing,
internal xts properties, and perhaps most uniquely
- user added attributes.

\subsubsection*{True time-based indexes}
To allow for functions that make use of {\tt xts} objects
as a general time-series object - it was necessary to
impose a simple rule on the class.  The index of each
{\tt xts} object \emph{must} be of a known and supported
time or date class.  At present this includes any one of
the following - Date, POSIXct, chron, yearmon, yearqtr, or
timeDate.  The relative merits of each of are left to
the judgement of the user, though the first three are expected
to be sufficient for most applications.

\subsubsection*{Internal attributes: .CLASS, .ROWNAMES, etc.}
In order for one major feature of the {\tt xts} class
to be possible - the conversion and re-conversion of classes
to and from {\tt xts} - certain elements must be preserved within
a converted object.  These are for internal use, and
as such require little further explanation in an introductory
document.

\subsubsection*{xtsAttributes}
This is what makes the xts class an \emph{extensible}
time-series class. Arbitrary attributes may be assigned
and removed from the object without causing issues, display or
otherwise.  Additionally this is where \emph{other}
class specific attributes (e.g. FinCenter from timeSeries)
are stored during conversion
to an xts object, so they may be restored with {\tt reclass}.

\section{Using the {\tt xts} package}
Just what is required to start using {\tt xts}?  Nothing more
than a simple conversion of your current time-series data, or
using the {\tt xts} constructor to create a new object.

\subsection{Creating data objects: {\tt as.xts} and {\tt xts}}
There are two equally valid mechanisms to create an {\tt xts}
object - coerce a supported time-series class to {\tt xts} with
a call to {\tt as.xts}, or create a new object from scratch
with {\tt xts}.

\subsubsection*{Converting your \emph{existing} time-series data: {\tt as.xts}}
If you already are comfortable using a particular
time-series class in {\tt R}, you can still access
the functionality of {\tt xts} by converting your
current objects.

Presently it is possible to convert all the major
time-series like classes in {\tt R} to {\tt xts}. This list
includes objects of class:
matrix, data.frame, ts, zoo, irts, its, and timeSeries.
The new object will maintain all the necessary information
needed to {\tt reclass} this object back to its
original class if that is desired. At present most classes
after re-conversion will be identical to similar modifications
on the original object, even
after sub-setting or other changes while an {\tt xts} object.

<<a>>=
require(xts)
data(sample_matrix)
class(sample_matrix)
str(sample_matrix)
matrix_xts <- as.xts(sample_matrix,dateFormat='Date')
str(matrix_xts)
df_xts <- as.xts(as.data.frame(sample_matrix),
 important='very important info!')
str(df_xts)
@

A few comments about the above. {\tt as.xts} takes different arguments, depending
on the original object to be converted from.  Some classes do not contain enough
information to infer a time-date class. If that is the case, POSIXct is used by
default. This is the case with both matrix and data.frame object. In the preceding
examples we first requested that the new date format be of type 'Date'.  The
second example was left to the default {\tt xts} method, this
time with a custom attribute added.

\subsubsection*{Creating new data: the {\tt xts} constructor}
Data objects can also be constructed directly from raw data with
the {\tt  xts} constructor function, in essentially the same way
a {\tt  zoo} object is created with the exception that at present
there is no equivelant {\tt zooreg} class.

\subsection{{\tt xts} methods}
There is a full complement of standard methods to make use of the features
present in {\tt xts} objects. The generic methods currently
extended to {\tt xts} include ``{\tt [}'',
{\tt cbind}, {\tt rbind}, {\tt c}, {\tt str}, {\tt Ops},
{\tt print}, {\tt na.omit}, {\tt time}, {\tt index},
{\tt plot}, {\tt coredata}. In addition, most methods that can accept
zoo or matrix objects will simply work as expected.

A quick tour of some of the methods unique to {\tt xts}
will be presented here, including subsetting via ``{\tt [}'',
indexing options with {\tt indexClass} and {\tt convertIndex},
and a quick look at plotting {\tt xts} objects with the {\tt plot}
function.

\subsubsection*{Subsetting}
The most noticably difference in the behavior of \texttt{xts} objects
will be apparent in the use of the ``{\tt [}'' operator. Using
special notation, one can use date-like strings to extract
data based on the time-index.  Using increasing levels of time-detail,
it is possible to subset the object by year, week, days - or even seconds.

The {\em i} (row)
argument to the subset operator ``{\tt [}'', in addition to accepting numeric
values for indexing,
can also be a character string, or vector of characters,
left-specified with respect to the standard ISO 
time format --- {\em ``CCYY-MM-DD HH:MM:SS''}.  This means that for one 
to extract a particular month, it is necesssary to fully specify the 
year as well. To identify a particular hour, say all observations
in the eighth hour on January 1, 2007, one would likewise need
to include the full year, month and day - e.g. ``2007-01-01 08''. 

It is also possible to explicitly request a range of times via
this index-based subsetting, using a double colon operator: ``::''.
The basic form is {\em ``from::to''}, where both {\em from} and {\em to}
are optional.  If either side is missing, it is interpretted as
a request to retrieve data from the beginning, or through the end of the
data object.

Another benefit to this method is that exact starting and ending
times need not match the underlying data - the nearest available
observation will be returned that is within the requested time
period.

The following example shows how
to extract the entire month of March 2007 - without having to
manually identify the index positions or match the underlying
index type. The results have been abbreviated to save space.
<<xtsmethods, eval=FALSE>>=
matrix_xts['2007-03']
@
<<xtsmethods-hidden, echo=FALSE>>=
head(matrix_xts['2007-03'],5)
cat('...\n')
@

Now extract all the data from the beginning through
January 7, 2007.
<<xtsmethods2, eval=FALSE>>=
matrix_xts['::2007-01-07']
@
<<xtsmethods2-hidden, echo=FALSE>>=
matrix_xts['::2007-01-07']
@
Additional xts tools providing subsetting ability are the
{\tt first} and {\tt last} functions.
Essentially an extension to head and tail from
the {\em utils} recommended package, they allow
for string based subsetting, without forcing
the user to conform to the specifics of the
time index, similar in usage to the {\em by}
arguments of aggregate.zoo and seq.POSIXt.

Here is the first 1 week of the data
<<xtsfirstandlast, eval=FALSE>>=
first(matrix_xts,'1 week')
@
<<xtsfirstandlast-hidden, echo=FALSE>>=
head(first(matrix_xts,'1 week'))
@

...and here is the first 3 days of the
last week of the data.
<<xtsfirstandlast2>>=
first(last(matrix_xts,'1 week'),'3 days')
@
\subsubsection*{Indexing}
While the subsetting ability of the above makes
exactly {\em which} time-based class you choose
for your index a bit less relevant, it is none-the-less
a factor that is beneficial to have control over.

To that end, {\tt xts} provides facilities for indexing
based on any of the current time-based classes. These
include {\tt Date}, {\tt POSIXct}, {\tt chron}, {\tt yearmon},
{\tt yearqtr}, and {\tt timeDate}.  The index itself may
be accessed via the zoo generics adapted extended to xts --- {\tt index} and
the replacement function {\tt index<-}.

It is also possible to directly query and set the
index class of an {\tt xts} object by using the functions
{\tt indexClass} and its in-place replacement method {\tt indexClass<-}.
Temporary conversion, resulting in a new object with the requested
index class, can be accomplished via the {\tt convertIndex} function.

\subsubsection*{Plotting}
\SweaveOpts{height=5,width=10}
%\setkeys{Gin}{width=0.8\textwidth}
The use of time-based indexes within {\tt xts} allows
for assumptions to be made regarding the x-axis
of plots. The {\tt plot} method
makes use of the {\tt xts} function {\tt axTicksByTime}, which
heuristically identifies suitable tickmark locations
for printing given a time-based object. 

When {\tt axTickByTime} is called with its
{\tt ticks.on} argument set to ``auto'', the result
is a vector of suitably chosen tickmark locations.
One can also specify the specific points to use
by passing a character string to the argument
indicating which time period to create tickmarks on.
<<xtsaxTicksByTime>>=
axTicksByTime(matrix_xts,'months')
@
A simple example of the plotting functionality
offered by this labelling can be seen here:
\begin{center}
<<xtsplot, fig=TRUE>>=
plot(matrix_xts,major.ticks='months',minor.ticks=FALSE,main=NULL,col=3)
@
\end{center}

\subsection{Restoring the original class - {\tt reclass}}
By now you may be interested in some of the xts functionality
presented, and wondering how to incorporate it into
a current workflow --- but not yet ready to commit
to using it exclusively.

If it is desirable to only use the subsetting tools
for instance, a quick conversion to xts via {\tt as.xts}
will allow full access to the above subsetting tools. When
it is then necessary to continue your analysis using
the original class, it is as simple as calling the
function {\tt reclass} to return the object to its
original class.

This differs dramatically from the standard {\tt as}
conversion though. Internally key attributes of your
original data object are preserved and adjusted to
assure that the process introduces no changes other
than those requested.  Think of it as a smart {\tt as}.

{\tt reclass} is of much greater use behind the scenes
in functions that convert all incoming data to {\tt xts}
for simplified processing. Often it is necessary to
return an object back to the user in the class they
are expecting. It is here where {\tt reclass} can
make hours of development into minutes per function. More
details on this will be covered later in the developing with
xts section of this document.

\subsection{Additional time-based tools}
In addition to the core {\tt xts} tools covered
above, there are more functions that are included
in xts to make the process of dealing with
time-series data easier.

\subsubsection*{Calculate periodicity}
The {\tt periodicity} function provides
a quick summary as to the underlying
periodicity of most time-series like
objects. Primarily a wrapper to {\tt difftime}
it provides a quick and concise summary
of your data.
<<periodicity>>=
periodicity(matrix_xts)
@
\subsubsection*{Find endpoints by time}
Another common issue with time-series data
is identifying the endpoints with respect to
time. Often it is necessary to break data
into hourly or monthly intervals to calculate
some statistic. A simple call to {\tt endpoints}
offers a quick vector of values suitable
for subsetting a dataset by.
<<endpoints>>=
endpoints(matrix_xts,on='months')
endpoints(matrix_xts,on='weeks')
@
\subsubsection*{Change periodicity}
One of the most ubiquitous type of data
in finance is OHLC data (Open-High-Low-Close). Often is is necessary
to change the periodicity of this data to something
coarser - e.g. take daily data and aggregate to weekly
or monthly.  With {\tt to.period} and related wrapper
functions it is a simple proposition.
<<toperiod>>=
to.period(matrix_xts,'months')
periodicity(to.period(matrix_xts,'months'))

# changing the index to something more appropriate
to.monthly(matrix_xts)
@
The {\tt to.monthly} wrapper requests that the
returned object have an index/rownames using
the {\tt yearmon} class. With the {\tt indexAt}
argument it is possible to align most series
returned to the end of the month, the beginning,
the first observation, the last observation --- or
even something like {\tt yearmon}.  The online
documentation provides more details as to additional
arguments.

\subsubsection*{Periodically apply a function}
Often it is desirable to be able to calculate a
particular statistic, or evaluate a function, over
a set of non-overlapping time periods. With the
{\tt period.apply} family of functions
it is quite simple:

<<periodapply>>=
period.apply(matrix_xts[,4],endpoints(matrix_xts),mean)

period.sum(matrix_xts[,4], endpoints(matrix_xts))

apply.monthly(matrix_xts[,4],mean)
@
 
\section{Developing with {\tt xts}}

\subsection{One function for all classes}

\subsection{Returning the original class}

<<b>>=

@

\vspace{2mm}
\noindent

\section{Customizing and Extending xts}

\subsection{{\tt xtsAttributes}}
<<c>>=

@

\vspace{2mm}
\noindent

\subsection{Subclassing {\tt xts}}
<<d>>=

@

\section{Conclusion}

\vspace{2mm}
\noindent

\begin{thebibliography}{99}
\bibitem{tseries} author:
\emph{tseries:},
R package version v, CCYY
\bibitem{rmetrics} DW:
\emph{Rmetrics:},

\bibitem{its} :
\emph{its: Irregular Time Series},

\bibitem{zoo} DW:
\emph{zoo: Z's Ordered Observations},

\bibitem{R} R Development Core Team:
\emph{R: A Language and Environment for Statistical Computing},
R Foundation for Statistical Computing, Vienna, Austria.
ISBN 3-900051-07-0, URL http://www.R-project.org
\bibitem{p} Jeffrey A. Ryan:
\emph{Defaults: Create Global Function Defaults},
R package version 1.1-0, 2007
\end{thebibliography}
\end{document}
